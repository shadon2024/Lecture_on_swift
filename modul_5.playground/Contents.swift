import UIKit
import Foundation

/// Основы swift - разработки.  Работа с массивами
/// Цель и задачи модуля
/// Цель: научиться работать с массивами и замыканиями
/// Задачи:
/// - научиться использовать массиви
/// - узнать, как получать доступ к элементам массивов
/// - использовать функции высшего порядка для опраций над массивами
/// - узнать, что тако замыкания и как их использовать
/// - научиться использовать множства
///
///
/// Массив - это контейнер для упрядоченного хранения значений одного типа
/// - Тип Array
/// - Значения могут быть типа optional
/// - Каждый элемент имеет индекс
/// - Передаются по значению
/// - Значчение могут повторятся

//1) Инциализировать массив таким образом
var someInt: [Int] = []
someInt.count // сколько элементов в массиве

//2) Инциализировать массив таким образом
var someDouble = [Double?]()
someDouble.isEmpty // показивает на тот пустой массив или нет


//print(someInt.count)
//print(someDouble.isEmpty)

// массив с пред заданными значчениями
var threeDoubles = Array(repeating: 0.0, count: 3) // данный констуктор вернет нам с тремя значениями


// массив с помощью литералов
var names = ["Alice", "Bob", "Christy"]
//for name in names {
//    print(name)
//}
//print(names)
//print(names[2]) // обращения к массиву к элемнтам по индксу

// добавление новое имя (то есть новое значчение)
names.insert("Ivan", at: 2)
//print(names)
/// массив передается по значению то есть при передаче в функции передается копия

var names2 = names
names2.insert("Vasy", at: 1)
//names.insert("Vasy", at: 1)
print(names2)
print(names)



/*
 Инициализация и полезные свойства массивов
 Вы уже знаете, что массив — упорядоченная коллекция данных любого, но одного типа. Перечислим способы создания массива (инициализации). Инициализировать массив можно несколькими способами:

 Создать пустой массив
 */

let someInts = [Int]()
let someAnotherInts: [Int] = []

// Через литералы массива
let someString: [String] = ["string1", "string2"]

// Массив со значением по умолчанию
let someDouble1 = Array(repeating: 0.1, count: 4)


/*
 Свойство count()
 У массива есть полезные свойства, которыми можно эффективно пользоваться.

 Например, count(), с помощью которого можно получить количество элементов в массиве и использовать в циклах для итерации по массиву.
 */
let array: [Int] = [1,2,3,4,5,6]
print(array.count)

/*
 С помощью свойства count() можно узнать, пустой ли массив, методом сравнения, например array.count == 0. В это же время можно использовать специальное свойство isEmpty, которое вернёт нам true или false в зависимости от наполненности массива.
 */
let firstArray: [Int] = [1,2,3]
let secondArray: [Int] = []
//print(firstArray.isEmpty)
//print(secondArray.isEmpty)


//Каким будет результат выполнения?
//if array.count != 0 {
//    print("Проверка 1: в массиве не пусто")
//} else if array.isEmpty {
//    print("Проверка 2: в массиве  пусто")
//} else if array.count == 0 {
//    print("Проверка 3: в массиве  пусто")
//} // print Проверка 1: в массиве не пусто



// Каким будет результат выполнения?
//let array: [Int] = [“one”, 2, 3, 4, “five”, 6]
//
//if array.count != 0 {
//  print(“Проверка 1: в массиве не пусто”)
//}  else if array.isEmpty {
//  print(“Проверка 2: в массиве пусто”)
//} else if array.count == 0 {
//  print(“Проверка 3: в массиве пусто”)
//}
// Возникнет ошибка компиляции, так как массив может состоять только из элементов одного типа. Тут же попытка создать массив с элементами типа string (“one”, “five”) и int (2, 3, 4, 6).

//
//Каким будет результат выполнения?
//let array: [Int] = []
//
//if array.count != 0 {
//  print(“Проверка 1: в массиве не пусто”)
//}  else if array.isEmpty {
//  print(“Проверка 2: в массиве пусто”)
//} else if array.count == 0 {
//  print(“Проверка 3: в массиве пусто”)
//}
// Во втором условии IF мы проверяем, что количество элементов в массиве равно 0, а значит, в массиве пусто. Так как второе условие выполняется, дальше проверка не пойдёт.


/// 5.4 Доступ к элементам массивов
/// - для доступа к элементу нужен индекс
/// - при удалении/добавлении элементов меняется нумерация последующих элементов
/// - использование индесов к квадратных скобках для доступа к элементам называется subscript
/// - если обьявить массив как let - массив становится константой и его нельзя изменять
/// - индексация элементов начинается с 0 (с нуля)


//var shopingList: [String] = ["Eggs", "Milk"]
//shopingList += ["Baking Powder"] // добавили новий элемент
////print(shopingList)
//
//var firstItem = shopingList[0]
//shopingList[0] = "Six eggs" //изменения элементов по индексу
////print(shopingList)
//
////shopingList[4...6] = ["Banans", "Apples"]
////print(shopingList)
//
//shopingList.insert("Maple Syrup", at: 0)
////print(shopingList) // добавление новий элемент
//
//let apleSyrup = shopingList.remove(at: 0)
//print(shopingList) // удаление элементов
//
//let apple = shopingList.removeLast()
//print(shopingList) // удаление элементов


// инциализация массив
var shopingList: [String] = ["Milk", "Eggs", "Bread", "Lemon", "Sugar"]

shopingList += ["Baking Powder"] // добавили новий элемент
//print(shopingList)

var firstItem = shopingList[0] // достать значения из массива subscript вернет значение 0
shopingList[0] = "Six eggs" //изменения элементов по индексу
//print(shopingList)

shopingList[3...5] = ["Banans", "Apples"] // изменеие элементов в массив от 3 до 5 будут заменены
//print(shopingList)

shopingList.insert("Maple Syrup", at: 0)
//print(shopingList) // добавление новий элемент (изменение количество элементов)

let apleSyrup = shopingList.remove(at: 0)
print(shopingList) // удаление элементов по индесу 0 (ноль)

let apple = shopingList.removeLast() // обертка
print(shopingList) // удаление элементов (удаления последного элемента)


/*
 5.5 Взаимодействие с элементами массива
 Что вы узнаете
 В этом материале вы повторите взаимодействие с элементами массива, рассмотрите способы обращения к конкретному элементу и итерирование по всему наполнению массива.
 */

// Обращение к элементу массива
//Рассмотрим разные способы обращения к элементу массива. Для этого инициализируем его командой:
let array1: [Int] = [1,2,3]

/// Первый способ: по индексу
//Если вы попробуете обратиться к элементу по индексу, выходящему за рамки массива, то возникнет crash и приложение упадёт:
//print(array1[0]) // 1

// Второй способ: по первому элементу
//Возвращает тип Optional, так как массив может оказаться пустым:
let firstElement = array.first
//print(firstElement ?? 0)
//print(firstElement!)

// Третий способ: по первому элементу, выполняющему условия
//Возвращает тип Optional, так как элемента, выполняющего условия в массиве, может не оказаться:
let firstNonZeroElement = array1.first { element in
    // В замыкании указываются условия для проверки элементов массива и определения первого подходящего.
    element != 0
}
//print(firstNonZeroElement ?? 0)
//print(firstNonZeroElement!)


// Четвёртый способ: по последнему элементу
//Возвращает тип Optional, так как массив может оказаться пустым:
let lastElement = array1.last
//print(lastElement ?? 0)
//print(lastElement!)


// Пятый способ: по последнему элементу, выполняющему условия
//Возвращает тип Optional, так как элемента, выполняющего условия, в массиве может не оказаться:
let lastNonZeroElement = array1.last { element in
    // В замыкании указываются условия для проверки элементов массива и определения последнего подходящего.
    element != 0
}
//print(lastNonZeroElement ?? 0)
//print(lastNonZeroElement!)


// Шестой способ: по случайному элементу
//Возвращает тип Optional, так как массив может оказаться пустым:
let randomElement = array1.randomElement()
//print(randomElement ?? 0)
//print(randomElement!)

let array3: [Int?] = [1, 2, 3, 4, 5 ,6]
//print(array3[5]!)
//print(array3[5] ?? 0)




/// Итерирование по массиву
///Итерирование по массиву также можно назвать пробегом по массиву. Для этого есть несколько способов, и вы можете выбрать подходящий вам. Синтаксис будет подсказывать, как перебирается массив и какие свойства используются.

//Рассмотрим два способа с использованием циклов, а также два способа с использованием метода массива. Для начала инициализируем массив командой:
let array4: [Int] = [1,2,3,4,5,6]

///Первый способ: цикл for — in для всего набора значений массива
for element in array4 {
    print(element)
}


/// Второй способ: цикл for — in для прохода по индексам элементов
//Используем свойство count для определения количества элементов в массиве. Так как индексация элементов начинается с 0, индекс последнего элемента будет равен count − 1.
//Промежуток 0 ..< array.count позволит использовать диапазон индексов от 0 до count − 1 и не выйти за рамки массива.
for index in 0..<array4.count {
    print(array4[index])
}


/// Третий способ: функция enumerated()
//Функция возвращает кортеж (тюпл), который содержит индекс и значение элемента массива:
for (index, value) in array4.enumerated() {
    print("Index = \(index) : value = \(value)")
}


/// Четвёртый способ: функция forEach()
//Функция перебирает все элементы массива:
array4.forEach{ element in
    print(element)
}
// Комбинация третьего и четвёртого способов
//Метод forEach() можно использовать с функцией enumerated():
array4.enumerated().forEach { index, element1 in
    print("Index = \(index) : element = \(element1)")
}

//Каким будет результат выполнения?
let array5: [Int] = [1, 2, 3, 4, 5 ,6]
for index in 0 ..< array5.count {
  if index % 2 == 0 {
     print(array5[index])
  }
}
//Верно!Верно, мы выводим значение только тех элементов массива, у которых индекс делится на два без остатка (в том числе нулевой индекс).


// Каким будет результат выполнения?
//let array6: [String] = [“one”, “two”, “three”, “four”, “five” ,”six”]
//for index in 0 … array6.count {
//  if index % 2 == 0 {
//     print(array6[index])
//  }
//}
//Верно! Верно, будет ошибка, так как для определения промежутка мы используем 0…array.count, а значит, цикл будет использовать значения от 0 до 6.
//При попытке обращения к элементу с индексом 6 возникнет ошибка, так как в этом массиве максимальный индекс равен count − 1, то есть 5



///
/// Поиск элемента в массиве
///
//Для поиска по элементам массива можно использовать циклы и замыкания.

///Например, поиск вручную:

let array7 : [Int] = [1,2,3,5]
var array7ContainsNumberFour = false
for element in array7 {
    if element == 4 {
        array7ContainsNumberFour = true
    }
}

if array7ContainsNumberFour {
    print("В массиве есть цифра 4")
} else {
    print("В массиве нет цифры 4")
}
// В итоге распечатается «В массиве нет цифры 4», так как массив array не содержит элемента со значением 4.


///
///Для удобства проверки наличия элемента в массиве можно использовать метод contains(), который возвращает bool-значение:
var array8: [Int] = [1,2,3,5]
//Метод contains() возвращает false, так как массив не содержит элемент со значением 4:
//print(array8.contains(4))

/// Метод append() используется для добавления элемента в конец массива:
array8.append(4)

/// Метод contains() возвращает true, так как после вставки нового элемента в предыдущем действии массив содержит элемент со значением 4:
print(array8.contains(4)) // true


/// Проверка на наличие элемента по определённым параметрам:
var array9: [Int] = [1,3,5]
let arrayContainsEvenNumber = array9.contains { element in
    // Проверка значения элемента на чётность:
    element % 2 == 0
}
//Значение arrayContainsEvenNumber будет равно false, так как массив array не содержит в себе чётных элементов:
print(arrayContainsEvenNumber)

//Выводы
//В этом материале мы повторили варианты взаимодействия с элементами массива.


///
///
///5.6 Операции над массивами
///
///

//Далее вы узнаете, как фильтровать, сортировать и изменять массивы под необходимые условия.

// - сортировка array.sort(by: {$0 > $1})
var array11 = [1,2,3,4,5,6]
array11.sort(by: {$0 > $1})
array11
//print(array11)

// - обьединение массивов array1 + array2


// - фильтрация array.filter({$0 % 2 == 0})
let filtred = array11.filter({$0 % 2 == 0})
filtred
//print(filtred)


// - переобразование массива array.map({$0 * $0})
let nowArray = array11.map({$0 * $0})
nowArray
//print(nowArray)


// работа в цикле (последовательность)
let shoppingList: [String] = ["Milk", "Eggs", "Bread", "Lemon", "Sugar"]
for (index, value) in shoppingList.enumerated() {
    print("индекс = \(index) : значение = \(value)")
}


// сортировка массивов (фукнция высшего порядка)
// сортировать по убиванию
var  array12: [Int] = [1,2,3,4,5,6] // массив состоящих из целых чисел
//фукнция высшего порядка
// sort - полмалчинию сортирует по вазрастанию
// sorted возвращает выходного параметра
array12.sort(by: { $0 > $1 } )
//print(array12)


// фильтрация
let filterr = array12.filter({ $0 % 2 == 0 })
//print(filterr)


// переобразавание массива
let newArray1 = array12.map({ $0 * $0 })
//print(newArray1)

// обьединение массива
// или конкатенация
let arrayy = array12 + array12
//print(arrayy)





/*
 Описание
 Свойства и методы массива
 Первый и последний элементы массива
 Мы можем получить первый элемент массива array, написав array.first, а последний — array.last. Важно знать, что эти свойства имеют опциональный тип, потому что в пустом массиве нет ни первого, ни последнего элемента. Поэтому нам нужно использовать любой из известных способов разворачивания опционала. Например, написать array.last!.
 Количество элементов в массиве
 Чтобы узнать количество элементов в массиве, мы используем свойство array.count.
 Проверка массива на пустоту
 Чтобы узнать, пустой ли массив, мы используем свойство array.isEmpty.
 Минимальный и максимальный элементы
 Свойства array.min и array.max позволяют получить минимальный и максимальный элемент в массиве соответственно. Эти свойства также опциональны, потому что пустой массив не имеет ни максимального, ни минимального элементов.
 
 Напоминание конструкции guard
 Конструкция guard выглядит следующим образом:

 guard someBoolExpression else {
     doSomething()
     return
 }

 someBoolExpression — это некоторое логическое условие, выполнение которого мы хотим гарантировать. В блоке else мы прописываем код, который нужно выполнить, если условие ложно.

 Если guard находится внутри функции, то в блоке else мы обязательно должны завершить выполнение функции словом return.

 func secondElement(array: [Int]) -> Int? {
 guard array.count >= 2 else {
     return nil
 }
 return array[1]
 }

 Данная функция возвращает второй элемент массива, а если он не существует (длина массива меньше 2), возвращает nil.
 */

let array13: [Int] = [1,2]

func secondElement(array13: [Int]) -> Int? {
    guard array13.count >= 2 else {
        return nil
    }
return array13[1]
}
//print(secondElement(array13: [1]) ?? 0)
//print(secondElement(array13: [1]) ?? 0)




///
///
/// 5.7 Операции над массивами
//Что вы узнаете
//В этом материале вы повторите способы изменения массива.
//При работе с массивами может понадобиться изменить их наполнение, то есть добавить или удалить необходимые элементы, а может, и вовсе очистить массив.
//Также вы разберёте способы сортировки, фильтрации и преобразования массивов.



///
///
///Добавление элементов в массив
//Вы уже знаете, что массивы можно инициализировать двумя способами.
//Изменяемые массивы инициализируются как переменные: с помощью ключевого слова var.
//Массивы, которые не будут изменяться, инициализируются как константы: с помощью ключевого слова let.
//Теперь внимательнее рассмотрим возможности для добавления элементов в массив.


/// Добавление элемента в конец массива:
var array14: [Int] = [1,2,3,4]
array14.append(10)
//print(array14)


/// Добавление другого массива к текущему:
var array15: [Int] = [1,2]
let secondArray15: [Int] = [2,2]
let thirdArray15: [Int] = [3,3]

array15.append(contentsOf: secondArray15)
//print(array15)

array15 += thirdArray15
//print(array15)


/// Добавление элементов в конкретный индекс:
var firstArray16: [Int] = [1,1]
let secondArray16: [Int] = [2,2]

firstArray16.insert(10, at: 1)
//print(firstArray16)


/// Добавление одного массива в другой по индексу:
firstArray16.insert(contentsOf: secondArray16, at: 1)
//print(firstArray16)

firstArray16.insert(contentsOf: [4, 5, 6],  at: 0)
//print(firstArray16)

// Важно! Будьте внимательны при использовании метода insert(), так как, если вы укажете индекс, которого не существует, приложение «упадёт».
//Исключение — массив пустой и делается insert с индексом 0, то есть элемент вставляется на первое место.

//var firstArray: [Int] = [1, 1]
//firstArray.insert(0, at: 10) // Ошибка Array index is out of range



//Каким будет итоговый результат выполнения?
let array22: [Int] = [1, 2, 3, 4, 5, 6]
var resultArray: [Int] = []
array22.forEach { element in
 if element % 2 == 0 {
    resultArray.append(element)
  } else {
    resultArray.insert(element, at: 0)
  }
}
print(resultArray)

/*
 Отлично!
 С помощью замыкания forEach мы проходим по всем элементам массива и проверяем их на чётность.
 Если число чётное (делится на 2 без остатка), то добавляем его в конец массива resultArray.
 Если число нечётное (делится на 2 с остатком), то добавляем его на место с индексом 0, то есть в начало массива resultArray.
 Таким образом, получаем [5, 3, 1, 2, 4, 6].
 */


///
///
///Удаление элементов из массива
//Рассмотрим способы удаления элементов.


///Удаление элемента по индексу:
var array16: [Int] = [1,2,3]
let removedElement = array16.remove(at: 1)
//print(array16)


///Удаление первого элемента:
var array17: [Int] = [1,2,3]
let removedElementFirst = array17.removeFirst()
//print(array17)


/// Удаление последнего элемента:
var array18: [Int] = [1,2,3,8]
let removedElementLast = array18.removeLast()
//print(array18)
//print(removedElementLast)  паказиваеть какой элемент удалил
// Предыдущие три способа удаляют элемент из массива и возвращают его в качестве значения.



/// Удаление всех элементов, удовлетворяющих условию:
var array19: [Int] = [1,2,3,4,5,6,7,8,10,12,8]
//print(array19)
array19.removeAll(where: {element in
    element % 2 == 0
})
print(array19)


/// Удаление всех элементов:
var array20: [Int] = [1,2,3,4,5,6,7,8]
array20.removeAll()
//print(array20)


/// Сортировка элементов из массива
//
//Рассмотрим способы сортировки элементов.
//Для этого будут использоваться замыкания sort() и sorted(), в которых мы укажем условия для сортировки.

var array21: [Int] = [1,2,3,4,5,6,7,8,9,10,12,12,6]
//print(array21)
// Метод sort() сортирует сам массив:

array21.sort { item1, item2 in
    // Условие: каждый предыдущий элемент должен быть больше следующего.
       item1 > item2
}
//print(array21)

//Метод sorted() возвращает отсортированный массив:

let sortedArray = array21.sorted{ item1, item2 in
    // Условие: каждый предыдущий элемент должен быть меньше следующего.
        item1 < item2
}
//print(array21)
//print(sortedArray)

//Условия для сортировки могут быть разными. Необязательно сортировать по возрастанию или убыванию. Например, можно отсортировать так, чтобы вынести в начало массива элементы с одинаковыми значениями:

var notSortedArray: [Int] = [1,3,1,2,4,2,5,1,3]
//notSortedArray.sort() по вазрастанию
//print(notSortedArray)

let oneAtStartArray = notSortedArray.sorted { item1, item2 in
    // Условие: каждый предыдущий элемент должен быть равен 1 и каждый следующий — не равен 1.
    
    item1 == 1 && item2 != 1
}

// Таким образом, получается массив, где вначале собраны все элементы со значением 1.
// Остальные элементы свой порядок не меняют.
//print(oneAtStartArray)



///
///
/// Фильтрация элементов из массива
// Рассмотрим способы фильтрации элементов.
//Для фильтрации будет использоваться замыкание filter(), которое возвращает изменённый массив:

let arrayInt: [Int] = [1,4,5,3,6,2]
let filteredArrayInt = arrayInt.filter {
    item in
    // Условие: значение элемента делится на 2 без остатка.
        item % 2 == 0
}

// В результате получается массив, состоящий из чётных элементов.
//print(filteredArrayInt) // [4, 6, 2]

let arraySting1: [String] = ["Alex", "Bob", "Klark", "George", "John", "Aaron"]

let filteredArrayString = arraySting1.filter { item in
    // Условие: элемент содержит в себе букву «a» ИЛИ букву «A».
    // Таким образом, необходимо выполнение хотя бы одного из условий, чтобы элемент прошёл фильтрацию.
    item.contains("a") || item.contains("A")
}

// В результате получается массив элементов, содержащих в себе букву «a» или «A».
print(filteredArrayString) // ["Alex", "Klark", "Aaron"]




let arrayString2: [String] = ["ABlex", "BAob", "Klark", "George", "John", "Aaron"]
let filteredArrayString2 = arrayString2.filter { item in
    item.contains("B") && item.contains("A")
}
//print(filteredArrayString2)


let arrayInt2 = [1, 3, 6, 1, 8, 0, 4, 2]
let mappedArray = arrayInt2.map { item in
    if item > 3 {
        return item * 2
    } else {
        return item * 3
    }
}
//print(mappedArray)




///
///
///Преобразование элементов из массива
//Для преобразования будут использоваться замыкания map() и compactMap().
//Метод map() возвращает массив элементов, изменённых по заданным правилам:
let arrayInt20: [Int] = [1,4,5,3,6,3]
let mappedArrayInt20 = arrayInt20.map { item in
    // Правило: значение элемента увеличивается на 10.
      item + 10
}
// В результате получается массив элементов, где каждый элемент из первоначального массива увеличен на 10.
//print(mappedArrayInt20)

///
///Метод compactMap() возвращает массив элементов неопционального типа, изменённых по заданным правилам:
let arrayOptionString: [String?] = [nil, "Bob", "Klark", "nil", "John", "John", "Aaron", "Aaron", ]
let arrayString12 = arrayOptionString.compactMap{ item in
    // Конкретных условий нет, просто возвращаем элемент без изменений.
        item
}
// В результате получается массив неопциональных элементов с типом String.
//print(arrayString12)
// Таким образом, с помощью compactMap() можно легко исключать nil-значения из массива, получая в итоге массив с элементами неопционального типа.



///
///
///5.8 Замыкания
///
// Замыкания - это самостоятельный блок кода, которыйй можно передавать и вызывать, то есть вы можете создать переменную и присвоить ей замыканые

/// - Разные формы упращенного синтаксиса:
// - тип может определяться из контекста, его не надо указывать
// - если замыкание состоит из одного выражения, то не нужно писать return
// - краткое обозначчение аргументов $0 - первый аргумент, $1 - второй аргумент и так далее.
// - если в функции последний аргумент замыканий, то можно обьявить его прицепом в конце функции
/// Замыкания могут быть убегающими  - @escapcing


//Описание
//Для чего помещать замыкание в переменную?
//Предположим, что у нас будет не один массив, а несколько, к которым нужно применить одинаковый фильтр. Тогда нам будет удобнее написать замыкание в переменной и использовать его многократно, а не писать один и тот же код несколько раз.

//Вместо того, чтобы писать:

let array100 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
let array200 = [2, 3, 5, 7, 11, 13, 17, 19]
let even100 = array100.filter { number in
    number % 2 == 0
}

let even200 = array200.filter { number in
    number % 2 == 0
}

//Мы можем написать так:

let array122 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
let array222 = [2, 3, 5, 7, 11, 13, 17, 19]
let evenFilterClosure: (Int) -> Bool = { $0 % 2 == 0 }
let even122 = array122.filter(evenFilterClosure)
let even222 = array222.filter(evenFilterClosure)



// пример
var names11 = ["Alice", "Bob", "Bob", "Chrisry", "Chrisry",]
//let reversedNames = names11.sorted(by: { (s1: String, s2: String) -> (Bool) in
//    return s1 > s2
//})
//print(reversedNames)
let reversedNames = names11.sorted(){ $0 > $1}
//print(reversedNames)


// отсортирвали наш массив по убивании
let sortingClosers: (String, String) -> Bool = { $0 > $1}
var names12 = ["Alice", "Bob", "Chrisry", "Chrisry"]
let reversedNames1 = names12.sorted(by: sortingClosers)
//print(reversedNames1)


/// Убегающие или избегающие замыкания
///

var someVar = 3

var onButtonPressed: ()-> Void = {}

func closureSetter(_ closure: @escaping ()-> ())  {
    onButtonPressed = closure // область видимости это тело
    print("Closure is set")
}

closureSetter() { someVar += 1}



// Замыкания только присвоено, но не вызвано
print("someVar is \(someVar)")


// Вызов замыкание, например по нажатию кнопки
onButtonPressed()


// Замыкание отработало
print("someVar is \(someVar)")


///5.9 Замыкания
///
///
//О чём вы узнаете
//Замыкания — анонимные функции, которые можно передавать в качестве параметров в другие функции.
//Ранее вы уже использовали методы, в которые передаются замыкания: sort, filter, map. Далее вы рассмотрите, как упростить вид синтаксиса таких замыканий и использовать его на практике.



//Синтаксис замыкания и его передача в качестве параметра

//customPrintClosure — константа, которой присваивается замыкание, в котором выполняется действие:

let customPrintClosure: () -> Void = {
    print("Привет! Это замыкание с печатью!")
}
let anotherCustomPrintClosure: () -> Void =  {
    print("А это — другое замыкание с печатью!")
}



//runSomeClosure — функция, которая в качестве параметра принимает замыкание и выполняет его внутри себя:

//func runSomeClosure(closure: () -> Void) {
//    closure
//}


//При вызове функции runSomeClosure она выполнит замыкание внутри себя.
//При каждом выполнении будет вызываться код, описанный в инициализации замыкания.

//runSomeClosure(closure: customPrintClosure) // Привет! Это замыкание с печатью!
//runSomeClosure(closure: anotherCustomPrintClosure) // А это — другое замыкание с печатью!

//runSomeClosure (closure: customPrintClosure)


//Передаваемые замыкания могут быть различными. Так как замыкания — функции, то они могут работать с принятыми в себя параметрами.
//Список параметров указывается до ключевого слова in, а затем идут выражения:


let isNumberEqual10Closure: (Int) -> Void = { number in
    if number == 10 {
        print("Число равно 10")
    } else {
        print("Число не равно 10")
    }
}
let arrayCountClosure: ([Int]) -> Void = { array in
    print("Количество элементов в массиве равно \(array.count)")
}


// Однако, в таком случае ранее используемая функция runSomeClosure уже не подойдёт, так как её ожидаемый парамерт — () -> Void. В случае же с isNumberEqual10Closure замыкание имеет представление (Int) -> Void, поэтому нужно использовать функцию с подходящими параметрами:


func runIntClosure(number: Int, closure: (Int) -> Void) {
    closure(number)
}
func runArrayClosure(array: [Int], closure: ([Int]) -> Void) {
    closure(array)
}

runIntClosure(number: 5, closure: isNumberEqual10Closure) // Число не равно 10
runArrayClosure(array: [1, 2, 0, 4, 6], closure: arrayCountClosure) // Количество элементов в массиве равно 3


//Также можно не создавать отдельную константу с замыканием, чтобы передавать её в функцию, а задать значение параметра непосредственно при вызове функции:

runIntClosure(number: 6) { number in
    if number >= 0 {
        print("Число больше или равно 0")
    } else {
        print("Число меньше 0")
    }
} // Число больше или равно 0


runArrayClosure(array: [1, 2, 3, 4, 5]) { array in
    if array.contains(10) {
        print("В массиве есть число 10")
    } else {
        print("В массиве нет числа 10")
    }
}



// Каким будет результат выполнения?

let customClosure0: ([String]) -> Void = { array in
    var itemsCount = 0
    array.forEach { item in
        if item.contains("A") || item.contains("a") {
            itemsCount += 1
        }
    }
    print(itemsCount)
}
func someStringArrayClosure(array: [String], closure: ([String]) -> Void) {
    closure(array)
}
someStringArrayClosure(array: ["Alysha", "Ella", "Jay", "Betty", "Skyle"], closure: customClosure0)
// Верно!
//Отлично!
//Функция someStringArrayClosure принимает в себя массив строк и замыкание.
//Замыкание содержит код для подсчёта количества элементов в массиве, в которых содержится строка «A» или «a».
//При вызове замыкания внутри функции в него прокидывается массив array, а в результате печатается ответ «3», так как в массиве есть три элемента, которые подходят к условиям.





// Каким будет результат выполнения?
let customClosure1: ([String]) -> Void = { array in
    var itemsCount = 0
    array.forEach { item in
        if item.contains("A") {
            itemsCount += 1
        }
    }
    print(itemsCount)
}
func someStringArrayClosure1(array: [String], closure: ([String]) -> Void) {
    closure([ ])
}
someStringArrayClosure1(array: ["Alysha", "Ella", "Jay", "Betty", "Skyle"], closure: customClosure1)
// Верно!
//Отлично!
//Функция someStringArrayClosure принимает в себя массив строк и замыкание.
//Замыкание содержит код для подсчёта количества элементов в массиве, в которых содержится строка «A».
//При вызове замыкания внутри функции в него передаётся пустой массив [ ] и, так как в нём нет неподходящих элементов, ответ будет «0».
//В свою очередь, параметр array, передаваемый в функцию someStringArrayClosure, не используется внутри неё.




/// Упрощение синтаксиса замыкающего выражения
//Замыкания в общем случае имеют вид:

//{ (параметры) -> тип_возвращаемого_значения in
//    выражения
//}

//Если замыкания не имеют возвращаемого значения или параметров, то такие элементы при определении замыканий могут быть опущены.
//Пример поэтапного упрощения синтаксиса замыкания в методе sort:

// инициализация массива someInts:


var someInt44 = [3, 5, 3, 2, 1, 4]

// Передаваемое замыкание, в котором подробно указаны и типы передаваемых параметров (item1: String, item2: String), и тип возвращаемого значения Bool:

//someInt44.sort { (item1: String, item2: String) -> Bool in
//    return item1 > item2
//}


someInt44.sort { item1, item2 in item1 > item2}


//Язык SWIFT позволяет использовать автоматические имена аргументов для замыканий $0, $1, $2…
//Таким образом, можно опустить список принимаемых параметров, так как количество и тип имён будут вычислены автоматически на основании ожидаемого типа метода.

//$0 и $1 обращаются к первому и второму параметру замыкания соответственно:

someInt44.sort{ $0 > $1 }
//print(someInt44)


///Пример упрощения замыкания в методе filter:

var someInt45 = [3, 5, 3, 2, 1, 4]
var someFilterInts45 = someInt45.filter { item in
    item != 0
}

someFilterInts45 = someInt45.filter { $0 != 0}
//print(someFilterInts45)


//Пример упрощения замыкания в методе map: для преобразования элементов массива someInts будет использоваться инициализатор String( ) для типа String. В результате каждое число типа Int из массива someInts будет преобразовано в строку типа String.

//Данный инициализатор можно использовать для преобразования различных типов в строку, то есть целочисленных и дробных чисел, дат и другого.

var someInt46 = [3, 5, 3, 2, 1, 4]
var someStrings46 = someInt46.map { item in
    String(item)
}

someStrings46 = someInt46.map { String($0)}
print(someStrings46)







//Каким будет итоговый результат выполнения?
var someInts47: [Int] = [6, 3, 5, 2, 9, 4, 7, 1]

someInts47 = someInts47.filter { $0 % 3 == 0 }

var someStrings47 = someInts47.map { String($0) }
someStrings47 = someStrings47.filter { $0 != "six" }
print(someStrings47)

//Верно!
//Отлично!
//После инициализации массив someInts фильтруется с условием, что останутся только элементы, которые делятся на 3 без остатка, а именно [6, 3, 9].

//Затем создаётся новый массив someStrings, в котором каждый элемент из someInts преобразуется в строку. Таким образом получается массив ["6", "3", "9"].

//Далее происходит фильтрация массива someStrings с условием, что элемент не должен быть равен строке "six" и, так как таких элементов в массиве нет, то он останется без изменений.


///Захват значений
//Замыкания могут «захватывать» передаваемые в них значения.

//Например:

var firstNumber0 = 5
var secondNumber0 = 7

// Создаётся замыкание, в котором есть возвращаемый тип Int:
let customClosure00: () -> Int = {
    return firstNumber0 * secondNumber0
}

// Похожее замыкание, но уже с «захватом» значений:

//захват происходит благодаря помещению значений до ключевого слова in в квадратные скобки — [ ]:

let customCaptureListClosure0: () -> Int = { [firstNumber0, secondNumber0] in
    return firstNumber0 * secondNumber0
}
// Печатается результат выполнения замыкания: в обоих случаях он равен 35.
print(customClosure00()) // 35
print(customCaptureListClosure0()) // 35

//Изменяются первоначальные значения firstNumber и secondNumber:
firstNumber0 = 10
secondNumber0 = 2


// После изменения переменных при выполнении замыкания результат, в котором не был использован захват значений, изменится.
//Во втором случае результат останется тем же:
print(customClosure00()) // 20
print(customCaptureListClosure0()) // 35

// Заключение
//В этом материале вы повторили синтаксис замыканий, познакомились с возможностью их использования как в качестве самостоятельных функций, так и в качестве передаваемых параметров.

//Зная сокращённое написание функций высшего порядка (sort, filter, map…), можно значительно сокращать код.







///
///
///5.10 Работа с множествами
///
///Описание
//Важное отличие множества от массива в том, что множество — это неупорядоченная коллекция элементов. Это означает, что мы не можем полагаться на то, что элементы в множестве будут иметь один и тот же порядок при разных запусках программы. Мы не можем обращаться к элементу множества по индексу.
//То, как устроено хранение элементов в множестве, позволяет нам быстро проводить операцию поиска. Чтобы проверить, есть ли элемент в массиве, нам нужно затратить n операций (проверить каждый элемент), а множество умеет проверять это за одну операцию (фантастика!).
//Одним из важных различий является то, что в множестве все элементы различны, тогда как в массиве могут быть дубликаты.
///
///
/// Множества (Set)
// Set - ещё один тип колекций
// Значчения не должны повторяться то есть должны быть уникальнымы
// Значения в множестве не упрядочены, поэтому работать с индексом затруднительно
// Используются, когда нужно найти соответсвие/различия между двумя наборами данных одного типа. Примеры хорошо видны на диаграммах Венна
// - общие элементы
// - уникальные элементы
// - обьединение элементов

// инциализация множество тип String
var fruits: Set = ["apple", "banana", "orange"]

// добавление множество используем метод insert
// элементы унакальные (разные)
let result = fruits.insert("grape")
//print(result)
print(fruits)


// удаление элементов
let result1 = fruits.remove("orange")
print(result1!)
print(fruits)
//print(result1 ?? 0)

// они работают эдентиччно как в массиве
fruits.isEmpty // есть ли элемент в множестве
fruits.count // показывает количство элементов в множестве


/// специфические функции
// - обьединение множество
// - вычитаные множество

let cappuchino:Set = ["espresso", "milk", "milk foam"]
let americano:Set  = ["espresso", "water"]
let machiato:Set   = ["espresso", "milk foam"]
let latte:  Set    = ["espresso", "milk",]

//обьединение множество
let unionResult = machiato.union(latte)
print(unionResult)


//вычитаные множество
let substractingResult = cappuchino.subtracting(americano)
print(substractingResult)


// пересечение множество
let intersetionResult = latte.intersection(cappuchino)
print(intersetionResult)


// симметрическое разность
let sdResult = latte.symmetricDifference(americano)
print(sdResult)

// - узнали о коллекциях, научились использовать массивы и множество
// - узнали что такое замыкания и как их использовать
// - дополнительно можно почитать
// -- коллекции Swift
// -- pfvыкания Swift



///
///5.11 Множества
//Что вы узнаете
//Вы уже знаете, что множества — это неупорядоченные коллекции уникальных значений.
//Инициализация и изменение множеств похожи на работу с массивами, но есть отличия. О них подробнее поговорим в этом материале.

// Инициализация множества
//Сравним инициализацию массива и множества:
var someArray: Array<Int> = [4, 4, 6, 7, 4, 2]
var someSet:     Set<Int> = [4, 4, 6, 7, 4, 2]
//print(someArray)
//print(someSet)

//Множество можно инициализировать с использованием массива, в этом случае из списка пропадут дубликаты. Новый список будет содержать только уникальные значения, но порядок элементов в нём будет случайным:
var someArray1: Array<Int> = [4, 4, 6, 7, 4, 2]
var someSet1:     Set<Int> = Set(someArray1)
print(someArray1)
print(someSet1)


//Каким будет результат выполнения?
let someArrayNames = ["Atem", "Bob", "Jimm", "Violet", "Jimm", "atem", "Stanford"]
let someSetNames = Set(someArrayNames)
print(someSetNames.count)
// Верно!
//Верно, при инициализации множества останется только шесть уникальных элементов.


///
///
///Поиск элемента
//Для поиска по массиву используют метод contains():

let someNames2 = ["Atem", "Bob", "Jimm", "Violet"]
if someNames2.contains("Jimm") {
    print("Джим тут есть")
}

for name in someNames2 {
    if name == "Jimm" {
        print("Джим тут есть")
        break
    }
}


let someNames3: Set  = ["Atem", "Bob", "Jimm", "Violet"]
if someNames3.contains("Jimm") {
    print("Джим тут есть")
}






print("hello shodon")
///Сколько раз на печать выводится фраза «Джим тут есть» в результате выполнения кода?
let someArrayNames44 = ["Atem", "Albert", "Jimm", "Violet", "Jimm", "Bob", "Stanford"]
let someSetNames44: Set = Set(someArrayNames44)
for name in someArrayNames44 {
    if name == "Jimm" {
        print("Джим тут есть")
    
    }
}
if someSetNames44.contains("Jimm") {
    print("Джим тут есть")
}
// Верно!
//Верно, когда цикл проходит по массиву, при каждой встрече с элементом, равным “Jimm”, на печать выводится «Джим тут есть». Так как в массиве таких элементов два, фраза будет выведена дважды.
//При проверке множества на наличие элемента, равного  “Jimm”, также печатается фраза «Джим тут есть». Итого три раза.






//Сколько раз на печать выводится фраза «Джим тут есть» в результате выполнения кода?
let someArrayNames45 = ["Atem", "Albert", "Jimm", "Violet", "Jimm", "Bob", "Stanford"]
let someSetNames45: Set = Set(someArrayNames45)
for name in someArrayNames45 {
    if name == "Jimm" {
        print("Джим тут есть")
          break
    }
}
if someSetNames.contains("Jimm") {
    print("Джим тут есть")
}
//Верно!
//Верно, когда цикл проходит по массиву, при каждой встрече с элементом, равным “Jimm”, на печать выводится «Джим тут есть». С помощью оператора break выполнение цикла for in будет останавливаться, то есть команда печати для массива будет выведена единожды. При проверке множества на наличие элемента, равного “Jimm”, также печатается фраза «Джим тут есть». Итого два раза.







///
///
/// Равенство и взаимосвязь множеств
///
//К множествам можно применять разные методы для определения их взаимосвязи:
///

let firstSetNames2: Set = ["Atem", "Albert", "Jimm", "Violet", "Jimm", "Bob", "Stanford"]
let secondSetNames2: Set = ["Violet", "Stanford"]


//1. Определение равенства всех значений двух множеств:
print(firstSetNames2 == secondSetNames2) // false


//2. Определение того, что множество является подмножеством, с помощью isSubset(of:):
print(secondSetNames2.isSubset(of: firstSetNames2)) // true


//3. Определение того, что множество является надмножеством, с помощью isSuperset(of:):
print(firstSetNames2.isSuperset(of: secondSetNames2)) // true


//4. Определение того, что множества не имеют похожих значений, с помощью метода isDisjoint(with:). Функция возвращает true, когда общих значений нет, и false во всех остальных случаях:
print(firstSetNames2.isDisjoint(with: secondSetNames2)) // false

let thirdSetNames: Set = ["Carl", "Mabel"]
print(firstSetNames2.isDisjoint(with: thirdSetNames)) // true

//Выводы
//В этом материале вы повторили отличия возможностей множеств и массивов в языке Swift. В будущем при работе с большим количеством данных вы сможете выбрать вариант, подходящий под ваши задачи.

//Знание особых свойств каждого варианта поможет избавиться от лишних действий и увеличить скорость обработки процессов. Вы сможете эффективнее преобразовывать данные, искать необходимые значения и передавать данные между ресурсами в приложениях.












