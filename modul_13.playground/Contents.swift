import UIKit


//13.3 Жизненный цикл приложения и ViewController
//Что вы узнаете
//В этом материале вы повторите и более подробно изучите состояния приложения и этапы жизненного цикла ViewController, а также методы делегатов, благодаря которым можно взаимодействовать с состояниями приложения и контроллера.



//Стадии работы приложения
//
//Изображение:  официальная документация Apple
//
//Состояния приложения:
//
//Unattached («Не запущено») — приложение не запущено или запуск был приостановлен, ресурсы не выделяются.
//Foreground — Inactive («Передний план — неактивно») — приложение запущено; код программы выполняется, но не обрабатываются события приложения; ресурсы выделяются.
//Foreground — Active («Передний план — активно») — приложение запущено, обрабатываются все события, ресурсы выделяются.
//Background («Фон») — приложение запущено, находится в фоновом режиме, могут выполняться действия, работать код, ресурсы выделяются.
//Suspended («Приостановлено») — приложение запущено, находится в фоновом режиме, не выполняет код, ресурсы не выделяются.




//Методы делегатов состояния приложения
//В жизненном цикле приложения есть делегаты, методы которых реагируют на процессы в приложении, например запуск, получение уведомления или сворачивание. Через такие методы можно добавлять необходимую логику в приложение, например отправлять аналитику в нужные моменты или делать запрос в бэкенд.
//
//Начиная с iOS 13 на состояние приложения реагирует не только AppDelegate, как было раньше, но и SceneDelegate. Рассмотрим основные методы делегатов AppDelegate и SceneDelegate.
//
//AppDelegate
//AppDelegate может обрабатывать внешние сервисы, такие как push-уведомления, определение местоположения, завершение работы приложения и многое другое.
//
//func application(_:didFinishLaunchingWithOptions:) -> Bool
//
//Метод сообщает делегату, что процесс запуска почти завершён и приложение почти готово к запуску. Используется для завершения инициализации приложения и внесения окончательных настроек. В версиях ниже iOS 13 этот метод использовался для настройки объекта UIWindow и назначения экземпляра ViewController объекту UIWindow для отображения на экране. Начиная с iOS 13 обработка перемещается в SceneDelegate, если в приложении есть сцены.
//
//func application(_:didDiscardSceneSessions:)
//
//Метод сообщает делегату, что пользователь закрыл одну или несколько сцен приложения из переключателя приложений, при этом метод не вызывается, когда система отключает сцену, чтобы освободить память.
//
//Когда пользователь удаляет сцену из переключателя приложений, UIKit вызывает этот метод, прежде чем полностью отбросить объект, связанный со сценой. Если приложение не работает, UIKit вызывает этот метод при следующем запуске. Освобождение памяти удаляет объекты сцены, но сохраняет сеансы, связанные с этими сценами.
//
//SceneDelegate
//Начиная с iOS 13 UIWindow из AppDelegate связан с UIScene в SceneDelegate.
//
//SceneDelegate отвечает за отображаемое на экране в плане данных и пользовательского интерфейса.
//
//scene(_:willConnectTo:options:)
//
//Первый метод, который вызывается в жизненном цикле UISceneSession, сообщает делегату о добавлении новой сцены в приложение. Создаётся новое UIWindow, устанавливается корневой контроллер, и окно делается ключевым для отображения. Метод используется, чтобы отреагировать на добавление новой сцены и начать загрузку любых данных, которые сцена должна отображать.
//
//sceneWillEnterForeground(_ :)
//
//Метод сообщает делегату, что сцена скоро будет запущена на переднем плане и станет видимой для пользователя.
//
//sceneDidBecomeActive(_ :)
//
//Метод вызывается после sceneWillEnterForeground(_ :) и сообщает делегату, что сцена стала активной и отвечает на пользовательские события.
//
//sceneWillResignActive(_ :)
//
//Метод сообщает делегату, что сцена скоро выйдет из активного состояния и перестанет реагировать на действия пользователя.
//
//sceneDidEnterBackground(_ :)
//
//Метод сообщает делегату, что сцена запущена в фоне и больше не на экране.
//
//sceneDidDisconnect(_ :)
//
//Метод используется для очистки ресурсов перед тем, как сцена будет удалена из памяти.
//
//Используйте его для освобождения ссылок на файлы или общие ресурсы и для сохранения пользовательских данных.
//
//UIKit отключает сцену, когда пользователь явно закрывает её в переключателе приложений, но не отключает автоматически, когда пользователь переключается на другое приложение. UIKit также может отключить сцену, чтобы освободить память для других процессов, если на работу приложения затрачивается слишком много ресурсов.
//
//Используйте эти методы делегатов, чтобы настроить приложение при запуске или отреагировать на состояние приложения в процессе использования.




//Жизненный цикл ViewController
//Рассмотрим жизненный цикл ViewController подробнее. Общая схема приведена на изображении ниже, дальше будет поэтапное описание.



//Смоделируем ситуацию открытия и закрытия ViewController:
//
//init()
//Открываем ViewController, происходит его инициализация ViewController.init().
//
//isViewLoaded
//У контроллера проверяется параметр isViewLoaded. Если возвращается true, значит, view для этого контроллера уже создан, переходим сразу к открытию экрана и методу viewWillAppear(). При первом открытии isViewLoaded вернёт false, поэтому далее срабатывает метод loadView().
//
//loadView()
//Метод создаёт view для ViewController.
//
//viewDidLoad()
//Срабатывает, когда создан view для ViewController. Метод используется для заполнения интерфейса данными, прежде чем его увидит пользователь.
//
//viewWillAppear()
//Срабатывает перед появлением view на экране. Метод оповещает ViewController о появлении на экране. Границы определены, но ориентация экрана ещё не установлена.
//
//viewWillLayoutSubviews()
//Первый шаг в жизненном цикле, где границы уже известны. Метод можно использовать для обновления интерфейса, если UI задаётся не через constraints или AutoLayout, а, например, через frame. Вызывается каждый раз при изменении frame, например при повороте экрана или вызове функции вручную для обновления границ.
//
//viewDidLayoutSubviews()
//Метод оповещает ViewController, что все его subview установлены. Можно использовать для внесения изменений в subview после их установки.
//
//viewDidAppear()
//Срабатывает сразу после появления view на экране. Метод можно использовать для запуска анимации, загрузки данных из сети или базы данных.
//
//viewWillDisappear()
//Срабатывает перед уходом view с экрана.
//
//viewDidDisappear()
//Срабатывает после ухода view с экрана. Этот метод часто используется, чтобы остановить выполнение задач, пока view не находится на экране. ViewController может исчезать с экрана, но не всегда удаляется при этом из памяти. Когда вы открываете новые контроллеры, уходя в глубь навигации, текущий контроллер остаётся в памяти. Деинициализация ViewController происходит только при переходе вверх по навигационной иерархии.
//
//deinit()
//Метод, который срабатывает во время деинициализации ViewController перед удалением его из памяти.
//
//didReceiveMemoryWarning()
//Метод, который срабатывает при использовании слишком большого объёма ресурсов памяти устройства. Можно предпринять действия для освобождения части памяти, уменьшив нагрузку на систему. Если приложение превысит определённый порог использования ресурсов, то iOS может принудительно завершить работу приложения, для пользователя это будет выглядеть как крэш.
//Методы loadView и viewDidLoad срабатывают единожды при использовании контроллера, а viewWillAppear, viewDidAppear, viewWillDisappear, viewDidDisappear могут вызываться несколько раз. Например, когда происходит переход на другой контроллер и скрывается текущий, каждый раз будут срабатывать методы viewWillDisappear и viewDidDisappear, а при каждом возвращении на текущий контроллер заново вызываются viewWillAppear и viewDidAppear.


//Может ли приложение из состояния Background (фон) перейти в состояние Foreground — active («Передний план — активно»)?
//Да, состояние Background может показывать, что приложение свёрнуто и если его заново открыть, то состояние станет Foreground — active


//Вариант 4:
//loadView(),
//viewDidLoad(),
//viewWillAppear(),
//viewDidAppear(),
//viewWillDisappear(),
//viewDidDisappear()







//13.5 Навигация и навигационный контроллер
//Что вы узнаете
//В этом материале вы повторите, что такое навигационный контроллер, и подробно рассмотрите его наполнение. А также найдёте варианты открытия и закрытия экранов, которые можно использовать в зависимости от задач проекта.
//
//UINavigationController
//UINavigationController — это контроллер-контейнер. Он содержит стек из других контроллеров (ViewControllers), расположенных в иерархическом порядке.
//
//Обычно корневой контроллер в стеке — это контроллер, который был первым добавлен в NavigationController или установлен как его rootViewController. Верхний контроллер в стеке — это экран, который был открыт последним.



//В схеме выше используется экран Settings, в нём открывается экран General, а в General — Auto-Lock. Получается, Settings — корневой контроллер в навигационном стеке, а Auto-Lock — верхний.
//
//Как можно увидеть, навигационный контроллер в navigationBar всем контроллерам, кроме корневого, предоставляет кнопку возврата. Для General это Settings в верхнем левом углу, а для Auto-Lock — кнопка General.
//
//Рассмотрим взаимодействие UINavigationController с управляемыми объектами.


//viewControllers — навигационный стек, массив, в котором находятся контроллеры, добавленные в UINavigationController.
//
//navigationBar — панель навигации внизу экрана, которой управляет навигационный контроллер. Панель navigationBar — это тип UINavigationBar. Он имеет методы делегатов, на которые реагирует UINavigationController.
//
//toolBar — элемент управления, который отображает кнопки вдоль нижнего края интерфейса. Опционален, по стандарту скрыт. Пример toolBar — кнопки навигации в браузере Safari.


//delegate — объект, который содержит ссылки на методы, описанные в протоколе, и с помощью которого контроллер координирует взаимодействие с этим объектом.
//
//Контроллер, наследуемый от протокола UINavigationControllerDelegate, взаимодействуя с методами установленного ему делегата, может переопределять отображение других контроллеров, предоставлять настраиваемые анимации переходов и указывать предпочтительную ориентацию интерфейса навигации.
//
//Делегат можно использовать для выполнения дополнительных действий в ответ на изменения в интерфейсе навигации.




//Переходы по навигационному стеку
//Разберём варианты открытия и закрытия экранов в приложении.
//
//Один из способов открытия нового экрана — использование метода pushViewController(_:animated:) у навигационного контроллера.
//
//Метод помещает ViewController вверх навигационного стека и обновляет экран.
//
//Пример:
//
//let myViewController = MyCustomViewController()
//self.navigationController?.pushViewController(myViewController, animated: true)
//Так как метод вызывается у ViewController, в новый контроллер будет передаваться UINavigationController, а значит, внутри него тоже можно будет вызвать методы у навигационного контроллера.
//
//Вариантов закрытия существует несколько. Некоторые из них:
//
//Свайп с левого края экрана.
//
//Нажатие кнопки Back в панели навигации сверху. Если у предыдущего контроллера был указан Title, на кнопке будет его название.
//
//Программное закрытие с помощью метода popViewController(animated:). Этот метод удаляет текущий контроллер из навигационного стека и делает новый верхний контроллер в стеке активным. Если контроллер, в котором вызывается метод, корневой, метод не сработает. Другими словами, нельзя закрыть единственный контроллер в навигационном стеке.
//Пример:
//self.navigationController?.popViewController(animated: true)
//Программное закрытие путём вызова метода popToViewController(_:animated:). Метод делает передаваемый в качестве параметра контроллер верхним в навигационном стеке, при этом все контроллеры, которые были в стеке выше указываемого, закрываются. Указываемый контроллер обязательно должен быть в навигационном стеке.
//Для примера попробуем найти в навигационном стеке первый контроллер, который соответствует типу MyCustomViewController. И если такой контроллер есть, переключимся на него. Раскроем опционал через if, так как popToViewController в качестве параметра ожидает неопциональный UIViewController:
//if let firstVC = self.navigationController?.viewControllers.first(where: { $0 is MyCustomViewController }) {
//    self.navigationController?.popToViewController(firstVC, animated: true)
//}
//Программное закрытие с помощью метода popToRootViewController(animated:). Этот метод удаляет все контроллеры из навигационного стека, кроме корневого, и обновляет отображение.
//Пример:
//self.navigationController?.popToRootViewController(animated: true)
//Параметр animated в описываемых методах определяет, будет ли открытие или закрытие контроллера анимированным. Если выставляется true, окно появляется или скрывается с анимацией. Если false — экран отображается или закрывается сразу в итоговом положении.
//
//Ниже — пример открытия контроллера с помощью pushViewController(_:animated:) и закрытия свайпом слева или через кнопку возврата Screen 1.



//Модальное открытие контроллера
//Ещё один вариант открытия контроллера — модальное отображение экрана. Рассмотрим пример.
//
//Метод present(_:animated:completion:) модально открывает новый экран. Для этого существует два способа:
//
//Метод вызывается у контроллера, с которого необходимо открыть экран:
//self.present(myViewController, animated: true)
//Метод вызывается у навигационного контроллера:
//self.navigationController?.present(myViewController, animated: true)
//Стоит учитывать, что при использовании этого метода навигационный контроллер не помещается на новый экран: navigationController будет равен nil, поэтому не может быть там использован. Также на экране не отобразятся стандартные элементы навигации.
//
//Для закрытия экрана необходимо вызывать метод dismiss(animated:completion:) у самого контроллера:
//
//self.dismiss(animated: true)
//Можно также свайпнуть экран сверху вниз.
//
//Для следующего примера в левом верхнем углу экрана была создана кастомная кнопка Close и к ней было привязано действие с вызовом внутри: dismiss(animated:completion:).


// test 
