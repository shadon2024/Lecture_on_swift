import UIKit

/// 8.1  Классы и структуры в Swift
/*
 
 Цель и задачи модуля
 Цель: научиться работать со структурами и классами.
 Задачи:
 ● Научиться создавать структуры
 ● Научиться работать с классами
 ● Рассмотреть использование разных типов
 свойств и методов
 ● Разобрать важное отличие в использовании
 классов и структур
 
 Описание

 В этом модуле мы:

 изучим программирование на языке Swift;
 научимся работать со структурами и классами;
 рассмотрим методы и свойства в классах и структурах;
 разберём отличия в использовании классов и структур;
 рассмотрим, как устроен
 */



/// 8.2 Структуры
/*
 Описание
 В этом уроке мы:

 рассмотрим создание кастомных типов данных — назначение, объединяющее классы и структуры;
 рассмотрим, из чего состоят структуры, их свойства, методы и сабскрипты;
 рассмотрим функцию структуры — инициализатор, задающий начальное состояние структуры;
 разберём, чему подчиняются структуры, что такое протокол;
 разберём на примерах, как:
 создать структуру для хранения информации о разрешении,
 создать экземпляр структуры,
 обратиться к свойствам структуры,
 создать инициализатор,
 передаётся информация по значению.
 
 Структуры
 Структуры — это контейнеры для свойств
 и методов. Используются для создания
 своих типов данных.
 ● Содержат свойства
 ● Содержат методы
 ● Можно использовать subscript для доступа
 к данным. Пример: словари и массивы
 ● Содержат в себе инициализаторы
 для определения начального состояния.
 Автоматически генерируются
 ● Передаются по значению
 ● Нельзя отнаследоваться от других структур
 
 Описание
 В этом уроке мы:

 -рассмотрим создание кастомных типов данных — назначение, объединяющее классы и структуры;
 -рассмотрим, из чего состоят структуры, их свойства, методы и сабскрипты;
 -рассмотрим функцию структуры — инициализатор, задающий начальное состояние структуры;
 -разберём, чему подчиняются структуры, что такое протокол;
 -разберём на примерах, как:
 
 --создать структуру для хранения информации о разрешении,
 --создать экземпляр структуры,
 --обратиться к свойствам структуры,
 --создать инициализатор,
 --передаётся информация по значению.
 
 */

struct Resolution { // тело структур
    var width = 0   // свойство структур
    var height = 0
}

// создать экземпляр структур и вызвать инциализатор
let resolution = Resolution()
resolution.height


// вариант инциализатор
let resolution1 = Resolution(width: 5, height: 10)
//print(resolution1.height)
//print(resolution1.self)


// неуказанные начальные параметра
struct Resolution1 { // тело структур
    let width: Int   // свойство структур
    let height: Int
}
let  resolution2 = Resolution1(width: 5, height: 20)


// создаем инциализатор самы (структур)
struct Resolution2 {
    let width: Int
    let height: Int
    
    init(_ width: Int) {
        self.width = width
        self.height = 0
    }
  // мы явно указали наш инциализатор
}
let  resolution22 = Resolution2(20)


// структуры передаются по значению
// когда мы передаем структуры, мы копируем его значения

struct Resolution3 { // тело структур
    var width: Int   // свойство структур
    var height: Int
    
    // новый метод меняет height
    mutating func setHeight(_ height: Int) {
        self.height = height
    }
}
let resolution33 = Resolution3(width: 5, height: 10)
var resolution34 = resolution33

// поменяем height
resolution34.setHeight(2)

//print(resolution33)
//print(resolution34)






/// 8.3 Классы
/*
 Описание
 В этом уроке мы:

 -рассмотрим назначение классов — контейнеры для свойств и методов;
 -рассмотрим, как:
 -создать класс в коде,
 ---создать инстанс для класса,
 ---создать инициализатор,
 ---использовать инициализатор при создании инстанса,
 ---наследуется информация от родительского к дочернему классу;
 -разберём дополнительные возможности классов, сравним, что лучше: классы или структуры и почему;
 -разберём передачу классов по ссылке;
 -создадим второй экземпляр resolution.
 
 Классы
 ● Похожи по назначению на структуры
 ● Пример: UIViewController
 ● Могут наследоваться
 ● Передаются по ссылке, поэтому можно
 использовать для отслеживания состояния
 
 */

class Resolution44 { // тело класс
    var width = 0   // свойство класс
    var height = 0
}
// создаем инстанс нашего класса
let resolution44 = Resolution44()




class Resolution45 { // тело класс
    var width: Int   // свойство класс
    var height: Int  // указываем тип int
    
    // инциализируем класс (в отличие от структуры класс не создает автоматический конструктор)
    // создаем начального свойств сами
    
    init(width: Int, height: Int) {
        self.width = width
        self.height = height
    }
}
// создаем инстанс нашего класса
let resolution45 = Resolution45(width: 11, height: 22)

// - классы могут наследоваться от других классов
// - классы могут передаваться по ссылке а не по значению

// прощее использовать структур и еще он безопасний



class Resolution46 {
    var width: Int
    var height: Int
    
    init(width: Int, height: Int) {
        self.width = width
        self.height = height
    }
}
let resolution46 = Resolution46(width: 11, height: 22)
var resolution47 = resolution46

resolution46.width = 5

print(resolution46.width)
print(resolution47.width)

// в классах передается не копия значения а сам инстанс


/// Наследование класса
// дочерные классы наследуется от родительского класса

// родительский класс
class Mammal {
    let legNumber = 4
    
    // вызиваем метод
    func says() -> String {
        return ""
    }
}

// дочерный класс
class Cat: Mammal {
    override func says() -> String {
        return "Meow!"
    }
}

let cat = Cat() // инстанс
cat.legNumber // получаем свойство
print(cat.says())

// есть один минус ПРИ НАСЛЕДОВАНИЕ  на доччерные класс мы переносим все методы и свойства даже если они не нужны



/// 8.4 Свойства и методы сущностей
/*
 Описание
 В этом уроке мы:

 -разберём, что такое свойства и как они работают, на примере класса;
 -разберём, что такое ленивое свойство и как оно работает;
 -разберём, что такое статические свойства и для чего они используются;
 -разберём, что такое модификаторы доступа;
 -рассмотрим, какие бывают модификаторы: public, internal, file private, private;
 -разберём, что такое модуль.
 
 Свойства и методы
 Можно выделить следующие типы свойств
 и методов:
 ● вычисляемые свойства
 ● ленивые свойства
 ● статические методы и свойства
 
 lazy var decimalFormatter: NumberFormatter = {
     let formatter = NumberFormatter()
     return formatter
 }()

 static var highestUnlocedLevel = 1
 var currentLevel = 1

 static func unlock(_ level: Int) {
     if level > highestUnlocedLevel { highestUnlocedLevel = level}
 }

 static func isUnlocked(_ level: Int) -> Bool {
     return level <= highestUnlocedLevel
 }
 
 
 ///
 ////
 
 Mодификаторы доступа
 Модификаторы доступа используются
 для сокрытия внутренней реализации,
 с которой не должен взаимодействовать
 пользователь этой сущности.
 Модификаторы доступа бывают:
 ● public — доступно из другого модуля
 ● internal — доступно из текущего модуля
 ● fileprivate — доступно только в файле,
 в котором объявлен
 ● private — доступно внутри сущности,
 в которой был объявлен метод или свойство
 
 public class SomePublicClass {
     public var somePublicProrety = 0
 member
     var someInternalProrety = 0
 class member
     fileprivate func someFilePrivate() {}
 class member
     private func somePrivateMethod(){}
 member
 }
 */


// геометрические фигуры

class Shape {
    var width: Int
    var height: Int
    
    // вычисляемые свойства
    var sqare: Int {
        width * height
    }
    
    // инциализатор или констурктор
    init(width: Int, height: Int) {
        self.width = width
        self.height = height
    }
}

// создадим экземпляр class Shape
let shape = Shape(width: 10, height: 20)
print(shape.sqare)

shape.height = 30
print(shape.sqare)


// ленивые свойства
//
class Shape0 {
    var width: Int
    var height: Int
    
    // вычисляемые свойства
    lazy var sqare: Int = { // безимянные функции
        width * height
    }()
    
    // инциализатор или констурктор
    init(width: Int, height: Int) {
        self.width = width
        self.height = height
    }
}

// создадим экземпляр class Shape
let shape0 = Shape0(width: 10, height: 20)
print(shape0.sqare)
shape0.height = 30
print(shape0.sqare)


// статические методы и свойства
//
class Shape1 {
    static var width: Int = 5
    static var height: Int = 10
    
    //статические методы которые высляет площадь
    static func square() -> Int {
        width * height
    }
}
// обрашем к этим свойствам без создания экземпляра
print(Shape1.height)
print(Shape1.square())



// Mодификаторы доступа
//

struct Shape2 {
   // метод площадь (для использования)
    func square() -> String {
        return "Square"
    }
    
    // метод для внутренные реализации (не должно быть доступа)
    private func helperFuncion() -> String {
        return "Helper Funcion"
    }
    
}
// экземпляр  структуры
let shape2 = Shape2()






/// 8.5 Разница между структурами и классами
/*
 Описание
 В этом уроке мы:

 -рассмотрим различие в хранении памяти между структурами и классами, к чему это может привести;
 -разберём, где хранятся структуры, что такое стек и метод LIFO;
 -разберём, где хранятся классы, что такое heap;
 -разберём, из-за чего происходит утечка данных, и пути исправления;
 -разберём на примере метод работы автоматического счётчика ссылок;
 -разберём на примере, как происходит утечка данных.
 
 
 Разница между структурами
 и классами
 ● Классы передаются по ссылке,
 а структуры — по значению
 ● Структуры сохраняются в стеке
 ● Классы хранятся в куче (от англ. heap)
 ● Ссылки бывают сильные и слабые
 ● Если два класса ссылаются друг на друга,
 может возникнуть Retain-Cycle. Это приведёт
 к утечке памяти
 
 Итоги модуля
 ● Узнали, как использовать структуры и классы
 ● Узнали разные типы свойств и методов
 ● Разобрались в отличиях между структурами
 и классами
 ● Узнали про утечки памяти при использовании
 классов и как этого избежать
 */

class Person {
    var department: Department?
    
    // инциализатор вызивается при создания обьекта
    init() {
        print("person initialized")
    }
    
    // вызивается при удаления обьекта из памяти
    deinit {
        print("person deallocated")
    }
}

class Department {
    init() {
        print("department initialized")
    }
    
    deinit {
        print("department deallocated")
    }
}


// создаем в памяти Person
var person: Person? = Person()
// присваиваем Department к Person
person?.department = Department()
// сбросиваем счетчик ссылок в ноль
// с помощью nil
person = nil



/// утечка памяти
///
class Persons {
    var department: Departments?
    init() {
        print("person initialized")
    }
    
    deinit {
        print("person deallocated")
    }
}

class Departments {
    weak var persons: Persons? // исправим утечка памяти
    init() {
        print("department initialized")
    }
    
    deinit {
        print("department deallocated")
    }
}


// создаем в памяти Person
var persons: Persons? = Persons()
// присваиваем Department к Person
var department: Departments? = Departments()
persons?.department = department
department?.persons = persons
// сбросиваем счетчик ссылок в ноль
// с помощью nil
persons = nil
department = nil



///
///
/// 8.6 Типы Value и Reference
/*
 Что вы узнаете
 В этом материале вы повторите основную информацию о типе значений (Value type) и ссылочном типе (Reference type), а также рассмотрите на практике отличия в работе с ними.

 Объекты, которые вы используете при разработке, например строки, массивы, классы, относятся к одному из этих типов.
 
 
 Value и Reference types
 Вспомним основные свойства типов данных в Swift.

 Value type — тип значения:

 имеет собственный экземпляр данных,
 операции с одним экземпляром не влияют на другие экземпляры,
 хранится в стеке (stack).
 Reference type — ссылочный тип:

 разные переменные могут указывать на один и тот же объект в памяти,
 операции с одной переменной могут изменять другие переменные,
 хранится в куче (heap).
 В таблице ниже указано, к какому типу относится тот или иной тип объекта.

 Value type
 --Struct (структура)
 --Enum (перечисление)
 --Int (целочисленное число)
 --Double (дробное число)
 --String (строка)
 --Set (множество)
 --Tuple (тапл/кортеж)
 --Array (массив)
 --Dictionary (словарь)
 
 Reference type
 --Class (класс)
 --Function (функция)
 --Closure (замыкание)

 Возникает вопрос: может ли структура, которая является Value type, храниться в куче (heap)?

 Ответ: да, может, если экземпляр Value type — это часть экземпляра Reference type. Например, экземпляр структуры является частью экземпляра класса, и так как класс хранится в куче (heap), то и структура будет храниться в куче.

 Стек работает в статической памяти, а куча — в динамической.

 Также стоит помнить важный момент о наследовании: вы можете наследоваться от класса, перенимая его переменные и методы, но вы не можете наследоваться от структуры.

 Подробнее о типах Value и Reference — на странице официальной документации Swift.

 Далее приведены примеры для работы со структурами и классами.
 */

//Пример работы со структурами
//В качестве практики работы со структурами вам предстоит описать собственную структуру, создать её экземпляры, а также поэкспериментировать с изменениями структур, где вы попробуете изменить их данные, чтобы проверить свойство структур хранить каждый экземпляр отдельно в памяти.

//Опишите свой экземпляр структуры с внутренней переменной greeting типа String:

struct CustomStruct {
    var greeting: String
}
//Проинициализируйте CustomStruct в переменную structOne. Так как далее вы будете изменять переменную greeting в structOne, что, по сути, будет менять саму структуру, — она должна быть именно переменной, то есть определяться через ключевое слово var.

//Создайте константу structTwo, присвоив ей значение structOne:

var structOne = CustomStruct(greeting: "Hello") // Инициализация structOne
let structTwo = structOne // structOne копируется в structTwo
//Выведите на печать значение переменной greeting:

print(structOne.greeting) // Hello
print(structTwo.greeting) // Hello
//Поменяйте значение greeting у structOne:

structOne.greeting = "Hello, world"
//Снова выведите на печать значение переменной greeting:

print(structOne.greeting) // Hello, world
print(structTwo.greeting) // Hello
//Как можно видеть, у структуры structOne значение переменной greeting изменилось, а у structTwo осталось прежним, так как каждый из объектов этой структуры имеет свой уникальный экземпляр данных в памяти.

// Выводы
//В этом материале вы повторили, какие именно объекты относятся к типу значений и ссылочному типу, и вспомнили разницу в способах хранения данных типов:

//значения хранятся в стеке (stack),
//ссылочные объекты — в куче (heap).
//Также вы на практике разобрали разницу в работе со структурами и классами, где проверили, что для каждого экземпляра структуры создаётся свой объект в памяти, а экземпляры класса в памяти могут указывать на один и тот же объект.




///
///
///
///8.7 Управление памятью в iOS
/*
 Что вас ждёт
 В программировании мы постоянно работаем с данными, а значит и с памятью, необходимой для их хранения. Языки программирования можно разделить на два типа: с ручной и автоматической моделью памяти.

 Ручное управление памятью подразумевает, что программист создаёт объекты, выделяет под них память и удаляет их после использования. Эта модель эффективна с точки зрения ресурсов, но требует от программиста высшей квалификации. При этом большую часть его работы будет занимать именно описание работы с памятью.

 Автоматическое управление памятью подразумевает, что система самостоятельно выделяет память для объектов и удаляет переменные, которые не используются. С такой моделью проще работать, но нужно соблюдать определённые правила, выдвигаемые разработчиками платформ и языков программирования.

 При разработке под iOS применяют два механизма для работы со ссылками на объекты: Manual reference counting (MRC) и Automatic reference counting (ARC). В этом материале вы разберёте методы работы с ними и примеры потенциальных ошибок утечек памяти.
 
 
 
 
 Сравнение MRC и ARC
 Manual reference counting (MRC) используют при разработке на Objective C.

 Сейчас разработку в основном ведут на Swift, особенно в новых проектах, поэтому Objective C встречается редко. Тем не менее необходимо знать, какие механизмы в нём используются, чтобы легче представить работу со ссылками в Swift.

 При работе с MRC нужно вручную считать ссылки на объект: программист сам должен контролировать количество обращений к объекту. Это происходит при использовании команд:

 alloc/init — создание объекта (инициализация);
 retain — обращение к объекту, увеличение количества ссылок на одну;
 release — уменьшение количества ссылок на одну;
 deallock — удаление объекта из памяти, когда счётчик ссылок равен нулю.
 В таком случае важно внимательно относиться к подсчёту ссылок на объект. Ведь если у ненужного объекта остаётся лишняя ссылка — это утечка памяти, а когда происходит попытка обратиться к объекту, которого нет в памяти, то приложение падает.

 Также есть специальный механизм @autoreleasepool, который при своей деинициализации автоматически освобождает из памяти объекты в нём.

 @autoreleasepool {
    // Код, создающий автоматически освобождаемые объекты.
 }
 Automatic reference counting (ARC) применяют при разработке на Swift. ARC использует автоматический подсчёт ссылок на объект. Во время компиляции проекта компилятор автоматически расставляет команды увеличения и уменьшения количества ссылок на объект, а в процессе работы приложения ARC отслеживает количество ссылок.

 Когда объект создан, его счётчик ссылок установлен на единицу. Каждый раз, когда на объект делают сильную ссылку, счётчик увеличивается на единицу. Каждый раз, когда сильная ссылка перестаёт действовать на объект, счётчик уменьшается на один. Когда счётчик ссылок становится равным нулю, объект удаляется из памяти.

 Виды ссылок бывают двух типов: сильная (strong) и слабая (weak и unowned). Далее вы проверите, как ARC работает со ссылками этих типов.

 Подробнее об ARC вы можете узнать в официальной документации Swift.


 
 
 */

///Работа ARC на примере сильных ссылок
///
//Объект существует, пока на него указывает хотя бы одна сильная ссылка. К таким ссылкам относится ссылка типа strong, которая устанавливается по умолчанию при описании объекта, если нет другого условия. Сильные ссылки увеличивают количество ссылок на объект в счётчике ссылок на единицу.

//Рассмотрим это на практике.

//Создайте класс Person с константой name и инициализатором.

//В метод init(name: String) добавьте печать в консоль print("\(name) был инициализирован"). Этот метод отработает при инициализации объекта.

//Также добавьте print("\(name) был деинициализирован") в метод deinit. Он сработает, когда объект деинициализируется, то есть будет удалён из памяти.
/*
class Person {

    let name: String

    init(name: String) {

        self.name = name

        print("\(name) был инициализирован")

    }

    deinit {
        print("\(name) был деинициализирован")
    }
}
//Затем создайте опциональную переменную person1 с типом Person?

var person1: Person?
//Создайте экземпляр класса Person и присвойте его переменной person1:

person1 = Person(name: "Аркадий") // Счётчик ссылок +1
//Запустите код. В консоли вы увидите, что на печать вывелось только сообщение об инициализации.

//Так как в описании переменной person1 не указаны дополнительные ключевые слова, то person1 создаётся с сильной ссылкой. Чтобы объект удалился из памяти, необходимо явно обнулить её.

//Добавьте эту строку и снова запустите код:

person1 = nil  // Счётчик ссылок –1
//Теперь на печать выводятся сообщения об инициализации и деинициализации. Это значит, что в итоге объект был удалён из памяти, когда количество сильных ссылок на него стало равно нулю.

//Обновите пример, добавив дополнительную переменную person2 и присвоив ей значение person1. Запустите код:

var person1: Person?
var person2: Person?

person1 = Person(name: "Аркадий") // Счётчик ссылок person1 +1
person2 = person1  // Счётчик ссылок person1 +1

person1 = nil // Счётчик ссылок person1 –1
//На печать выводится только сообщение об инициализации, так как person2 имеет сильную ссылку, а значит увеличивает количество ссылок ещё на единицу. Теперь обнуления только у person1 недостаточно, чтобы удалить объект из памяти. В таком случае необходимо обнулять и сильную ссылку от person2. Добавьте обнуление person2 и запустите код:

person2 = nil // Счётчик ссылок -1
//В этом случае обнуляются обе сильные ссылки, поэтому объект в итоге будет удалён из памяти.

*/


/*
 Работа ARC на примере слабых ссылок
 Применение исключительно сильных ссылок может привести к появлению циклов удержания. Тогда объекты не будут уничтожаться из памяти, создавая её утечку. Чтобы не обнулять каждую сильную ссылку вручную, используют слабые ссылки, например при работе с делегатами или замыканиями.

 Слабые ссылки не увеличивают количество ссылок на объект в счётчике, а значит не удерживают его в памяти. Объект со слабой ссылкой описывают через ключевые слова weak и unowned.

 Объект weak опционален и автоматически становится nil, когда удаляется из памяти. При обращении к такому объекту ничего не произойдёт, так как он будет равен nil.

 Объект unowned не опционален, но так как ссылка слабая, он может может быть удалён из памяти. При обращении к такому объекту приложение упадёт.

 Рассмотрим, как изменится процесс подсчёта ссылок ARC при использовании слабых ссылок на примере того же класса Person.

 class Person {

     let name: String

     init(name: String) {

         self.name = name

         print("\(name) был инициализирован")
     }

     deinit {
         print("\(name) был деинициализирован")
     }
 }
 В этом случае определите person2 со слабой ссылкой через ключевое слово weak и запустите код:

 var person1: Person?
 weak var person2: Person?

 person1 = Person(name: "Аркадий") // Счётчик ссылок person1 +1
 person2 = person1  // Счётчик не увеличивается, так как ссылка слабая

 person1 = nil  // Счётчик ссылок person1 –1
 Теперь для удаления объекта из памяти достаточно обнулить единственную сильную ссылку, заданную через person1. Для примера person1 можно определить через weak и запустить код:

 weak var person1: Person?
 weak var person2: Person?

 person1 = Person(name: "Аркадий") // Счётчик не увеличивается, так как ссылка слабая
 person2 = person1  // Счётчик не увеличивается, так как ссылка слабая
  Теперь объект инициализируется и деинициализируется сам, так на него не указывает ни одна сильная ссылка.
 */



/*
 Проблема цикла сильных ссылок
 При работе с объектами в проекте могут возникать утечки памяти. Например, два объекта, в каждом из которых есть сильная ссылка другой, будут удерживать друг друга и не смогут освободиться из памяти. Такую проблему называют циклом сильных ссылок, или retain cycle.

 Рассмотрим эту ситуацию на примере с двумя классами, внутри каждого из которых будет экземпляр другого класса.

 Создайте два класса: учитель (Teacher) и студент (Student). У каждого экземпляра класса должен быть параметр name и экземпляр другого класса. При этом у каждого студента должен быть учитель, но у учителя может не быть студента. Teacher у класса Student не опционален и должен задаваться при инициализации, а Student у Teacher опционален и изначально равен nil. Также добавьте печать в консоль сообщения при инициализации и деинициализации классов.

 class Teacher {
     private var name: String
     var student: Student?
     init(name: String) {
         self.name = name
         print("\(name) был инициализирован")
     }
     deinit {
         print("\(name) был деинициализирован")
     }
 }

 class Student {
     private var name: String
     private var teacher: Teacher
     init(name: String, teacher: Teacher) {
         self.name = name
         self.teacher = teacher
         print("\(name) был инициализирован")
     }
     deinit {
         print("\(name) был деинициализирован")
     }
 }
 Создайте экземпляры классов:

  // Счётчик сильной ссылки на customTeacher +1
 var customTeacher: Teacher? = Teacher(name: "customTeacher")
 // Счётчик сильной ссылки на customStudent +1
 // Счётчик сильной ссылки на customTeacher +1
 // Используем «!» для принудительного развёртывания опционала
 var customStudent: Student? = Student(name: "customStudent", teacher: customTeacher!)
 Присвойте созданный экземпляр customStudent для переменной student у customTeacher.

 // Счётчик сильной ссылки на customStudent +1
 customTeacher?.student = customStudent
 Обнулите экземпляры классов:

 // Счётчик сильной ссылки на customTeacher –1
 customTeacher = nil

 // Счётчик сильной ссылки на customStudent –1
 customStudent = nil
 Теперь запустите код.

 CustomTeacher и customStudent обнуляются, но не деинициализируются, так как удерживают друг друга сильной ссылкой. Так возникает проблема цикла удержания, а объекты не удаляются из памяти, создавая её утечку.

 Исправьте ситуацию. Ведь у учителя может не быть студента (например, он может переходить к другим преподавателям) — это значит, что студента можно определять через слабую ссылку. Добавьте к описанию переменной s tudent ключевое слово weak.

 Запустите код. Теперь оба объекта и c ustomTeacher, и customStudent деинициализируются. При установке student у c ustomTeacher счётчик ссылок не увеличивается, так как student имеет слабую ссылку.

 Когда customStudent деинициализируется, он отпускает сильную ссылку у teacher, поэтому customTeacher тоже деинициализируется.

 Утечка данных исправлена. Теперь цикл сильных ссылок между классами отсутствует, а при необходимости экземпляры классов будут удалены из памяти.
 */



/*
 Проблема цикла удержания
 Ещё одна проблема утечки памяти — цикл удержания при работе с замыканиями.

 Вы уже знаете, что Swift использует ссылочную модель удержания переменных со счётчиком ссылок:

 система подсчитывает количество ссылок на переменную;
 если система «видит», что на переменную никто не подписан, то автоматически удаляет её из памяти.
 Это хорошая схема, которая может работать надёжно, но существует важная деталь. Что случится, если объект хранит ссылку сам на себя? Например, такая ситуация возможна, когда часть кода «ушла» в сеть с запросом и ждёт возврата данных в класс.

 Такой процесс называют циклом удержания. Мы получаем цикличную зависимость: наш код ссылается на код сети, а код сети — на наш код. Так наш код может «зависнуть» в системе и никогда не удалится из памяти.

 Избежать этого позволяют слабые ссылки. Рассмотрим их применение на примере.

 Допустим, есть класс зарплаты, который может уведомить, когда в кошельке закончатся деньги:

 class Salary {
         func notifyWhenCashEnds(completion: @escaping () -> Void) {
         …
             completion()
         }
 }
 Он может вызвать данный метод несколько раз и когда угодно, даже после удаления объекта. Например, вы создаёте новый класс с менеджером напоминаний, в котором хотите использовать этот метод. Чтобы при передаче замыкания не создать цикл удержания, обратитесь к вашей зарплате следующим образом:

 class AlarmManager {
     // ...
     func controlCash() {
         salary.notifyWhenCashEnds { [weak self] in
             guard let self = self else { return }
            alarm()
         }
     }
     func alarm() {
      // some alarm code
 }
 }
 Здесь в качестве замыкания вы описали фигурные скобки с [weak self] в качестве параметра. Это значит, что замыкание «держит» вызывающий объект (в нашем случае это инстанс AlarmManager) как «мягкую» ссылку. Перед обращением к самим себе нужно проверить, существуем ли мы до сих пор.
 
 Выводы
 В этом материале вы разобрали работу с памятью в iOS, специфику работы счётчиков ссылок MRC для Objective C и ARC для Swift. Рассмотрели проблемы, с которыми можно столкнуться при связывании объектов, и способы избежания взаимного удержания объектов сильными ссылками. Также на примере разобрали, как избежать создания цикла, при котором объект удерживает сам себя.

 В следующих темах вы будете более подробно разбирать способы оптимизации кода при работе в проекте. Сейчас мы рекомендуем всегда использовать weak self в замыканиях, чтобы избежать проблем с удержанием ссылок.
 */
